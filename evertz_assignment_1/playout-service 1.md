# Broadcaster Playlist Service

## Context

You’ve joined a team building software for a broadcaster. The broadcaster runs **100+ channels** (News, Sports, Kids, Regional feeds…). Each channel has a single, always-current **playlist**: an ordered list of segments that operators edit throughout the day.

Operators constantly make changes:

- Insert breaking segments at the top (e.g., “put this at index 0”)
- Move items around as schedules change
- Delete items when content is dropped or replaced

In production, playlists can be large (**1,000 to 4,000 items**). The UI uses **infinite scrolling** and is smooth once loaded, but correctness and performance issues are painful:

- The initial playlist load is **slow** for large channels, even though the browser can handle rendering once the data arrives.
- Sometimes playlist metadata shows the expected total, but a few items (often **2–3**) appear missing from what the UI renders. This is subtle, hard to reproduce, and breaks operator trust.
- Operators also report that items they _know_ exist occasionally don’t show up where expected after a sequence of edits (insert/move/delete), especially during busy shifts.

Multi-user editing and imperfect networks make it worse: clients can miss an update, then apply the next operation against a stale ordering. That can cause duplicates, gaps, or out-of-order behavior unless the backend can detect “you’re out of sync” before applying changes.

We want a backend service that supports pagination (for performance) and a **fingerprint mismatch check** (to detect stale client state before applying edits). We care most about correctness and testability.

---

## Goal

Build a small **HTTP API service** that manages channel playlists and playlist items, supports pagination, and validates a client-provided fingerprint against a server-computed fingerprint.

This challenge is intentionally **end-to-end test oriented**:

- You should test the system through the public HTTP endpoints (start the server and make HTTP calls).
- We expect most of your tests to be integration/E2E-style tests that validate real request/response behavior.
- You may still write unit tests if you like, but E2E tests are the primary evaluation signal.

You should also research API schema patterns (e.g., REST conventions, error envelope formats, cursor pagination response shapes) and choose a pattern you think fits best. Document your choice and tradeoffs in `DESIGN.md`.

---

## Core model

- Many channels
- Each channel has exactly one playlist
- A playlist is an ordered list of items
- Playlist items are ordered by an integer `index`

**Indexing rule (you choose, but must document):**

- 0-based indexing: indexes are `0..N-1`, OR
- 1-based indexing: indexes are `1..N`

A playlist is considered “healthy” if:

- all items have a valid integer index
- there are no duplicate indexes
- the playlist is contiguous (no gaps) according to your indexing rule
- listing items in index order returns all items exactly once

Minimum item fields:

- `itemId` (string/uuid; generated by server or client — your choice, document it)
- `channelId`
- `index` (int)
- `title` (string)

---

## Required API endpoints

### 1) Health

- `GET /health`
  - returns 200
  - can be plain text or JSON

---

### 2) List items (paginated)

- `GET /api/channels/{channelId}/playlist/items?limit=..&cursor=..`

**Requirements:**

- Must return items in correct playlist order (by index)
- Must support pagination for large playlists (1,000–4,000 items)
- Pagination strategy is your choice (cursor or offset)
- Response must include:
  - `items`
  - pagination continuation info (`nextCursor` or `offset/limit`)
  - `totalCount` (recommended but not strictly required)
  - `serverFingerprint` (required)

Example response:

```json
{
  "items": [
    { "itemId": "abc1", "index": 0, "title": "Office EP1 S1" },
    { "itemId": "abs2", "index": 1, "title": "Office EP2 S1" },
    { "itemId": "as23", "index": 2, "title": "Office EP3 S1" }
  ],
  "page": {
    "limit": 50,
    "nextCursor": "opaque-or-null",
    "hasMore": true
  },
  "totalCount": 4000,
  "serverFingerprint": "..."
}
```

Notes:

- If you use offset pagination, your `page` object can include `offset` and `nextOffset` instead.
- If `cursor` is omitted, treat it as the first page.

---

### 3) Insert item at index (shifts existing items)

- `POST /api/channels/{channelId}/playlist/items`

Body:

```json
{ "title": "Breaking News", "index": 0, "clientFingerprint": "..." }
```

Behavior:

- Compare `clientFingerprint` with current server fingerprint.
- If mismatch: return **409** with:

  ```json
  { "errorCode": "PLAYLIST_FINGERPRINT_MISMATCH", "serverFingerprint": "..." }
  ```

- If match:
  - Insert the new item at `index`
  - Shift existing items `index..end` by +1
  - Return the inserted item and the updated fingerprint

Recommended success response:

```json
{
  "item": { "itemId": "newId", "index": 0, "title": "Breaking News" },
  "serverFingerprint": "..."
}
```

---

### 4) Delete item (closes gap)

- `DELETE /api/channels/{channelId}/playlist/items/{itemId}`

How you pass `clientFingerprint` is your choice:

- request body (allowed), or
- header (e.g., `X-Client-Fingerprint`), or
- query param

You must document your choice and keep it consistent across endpoints.

Behavior:

- Compare `clientFingerprint` with current server fingerprint.
- If mismatch: return **409** with:

  ```json
  { "errorCode": "PLAYLIST_FINGERPRINT_MISMATCH", "serverFingerprint": "..." }
  ```

- If match:
  - Delete the item
  - Shift items after it by -1 to close the gap
  - Return updated fingerprint

Recommended success response:

```json
{ "serverFingerprint": "..." }
```

---

### 5) Move item (reorder with shifting)

- `POST /api/channels/{channelId}/playlist/items/{itemId}/move`

Body:

```json
{ "newIndex": 5, "clientFingerprint": "..." }
```

Behavior:

- Compare `clientFingerprint` with current server fingerprint.
- If mismatch: return **409** with:

  ```json
  { "errorCode": "PLAYLIST_FINGERPRINT_MISMATCH", "serverFingerprint": "..." }
  ```

- If match:
  - Move the item to `newIndex`
  - Shift other affected items appropriately
  - Return updated fingerprint (and optionally moved item)

Recommended success response:

```json
{
  "item": { "itemId": "abc1", "index": 5, "title": "..." },
  "serverFingerprint": "..."
}
```

---

### 6) Sync-check (fingerprint mismatch check)

- `POST /api/channels/{channelId}/playlist/sync-check`

Body:

```json
{ "clientFingerprint": "..." }
```

Responses:

- Match:
  - `200`
  - body: `{ "serverFingerprint": "..." }`

- Mismatch:
  - `409`
  - body: `{ "errorCode": "PLAYLIST_FINGERPRINT_MISMATCH", "serverFingerprint": "..." }`

---

## Fingerprint requirement

- The backend must compute a deterministic **playlist fingerprint** representing the current ordering of a channel’s playlist
- The client provides its last-known fingerprint on every mutating request
- On mismatch, the backend must refuse the operation with **409** and include the current `serverFingerprint`

You decide the fingerprint algorithm. Document:

- what inputs are included
- how it is computed (high level)
- tradeoffs (performance, collision risk, etc.)

---

## Persistence

Use **some kind of persistent layer** so the playlist survives process restarts.

- The persistence choice is up to you
- Document what you chose and why, including limitations

---

## End-to-End tests (primary deliverable)

We expect most tests to be end-to-end tests that start the server and exercise the HTTP API.

### Expectations

- Tests should start the service (or use a test harness that boots it in-process) and make real HTTP calls.
- Tests should validate request/response status codes, bodies, and ordering behavior.
- Tests should be deterministic and runnable with a single command.

### Must-have E2E tests

1. **Ordering invariants via API**

- After insert/delete/move through the API:
  - indexes are contiguous according to your indexing rule
  - no duplicates
  - no gaps
  - each item appears exactly once when listed in order

2. **Insert scenarios**

- insert at start
- insert in middle
- insert at end
- out-of-range insert behavior (choose a policy and test it)

3. **Delete scenarios**

- delete first/middle/last
- delete non-existent item behavior (choose a policy and test it)

4. **Move scenarios**

- move forward/backward
- move to same index
- out-of-range move behavior (choose a policy and test it)

5. **Pagination**

- list items across multiple pages
- iterating pages returns all items exactly once
- ordering is deterministic across pages
- `nextCursor/offset` behaves correctly

6. **Fingerprint mismatch**

- get the current `serverFingerprint` from list
- mutate successfully with matching `clientFingerprint`
- attempt mutation with a stale `clientFingerprint`:
  - `sync-check` returns 409
  - insert/delete/move return 409 and include `serverFingerprint`

> Unit tests are welcome, but E2E tests are the main expectation.

---

## Submission format (zip)

Submit a single zip containing:

1. `README.md`

- exact run steps
- exact test steps
- base URL + port
- sample curl commands

2. `DESIGN.md` (short)
   Include:

- persistence choice and data model
- pagination strategy and why
- fingerprint algorithm and tradeoffs
- how shifting is implemented safely
- API schema pattern choice and tradeoffs
- assumptions & limitations

3. Source code + tests + lockfiles

- backend implementation
- E2E tests
- dependency lockfiles (`package-lock.json`, `requirements.txt`, etc.)

---

## Setup expectations

We should be able to run tests with a small number of commands, e.g.:

- Node: `npm ci && npm test`
- Python: `pip install -r requirements.txt && pytest`

---

## Assumptions

Any assumptions must be documented in `ASSUMPTIONS.md`. Examples:

- 0-based vs 1-based indexing
- insert/move out-of-range behavior
- delete non-existent behavior
- pagination semantics under concurrent edits
- fingerprint inputs (IDs only? index+ID? etc.)
- extra error handling (e.g., 400 for malformed requests)

Note: We as a company believes in AI first approach, we use it everyday at work, so you are permitted to use AI in this assignment as well, but if you choose to do so, keep a document called `prompts.md`
